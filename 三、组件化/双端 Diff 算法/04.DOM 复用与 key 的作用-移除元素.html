<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DOM 复用与 key 的作用-移除元素</title>
</head>

<body>
  <div id="app"></div>
  <script src="../../un-vue/utils.js"></script>
  <script src="../../un-vue/reactivity.js"></script>
  <script src="../../un-vue/render.js"></script>
  <script src="../../un-vue/components.js"></script>
  <script>
    function patchChildren(oNode, nNode, container) {
      // 判断子节点的类型是否为文本节点
      if (typeof nNode.children === "string") {
        // 旧子节点的类型有三种可能：没有子节点、文本子节点以及一组子节点
        // 只有当旧子节点为一组子节点时，才需要逐个卸载，其他情况下的什么都不需要做
        if (Array.isArray(oNode.children)) {
          oNode.children.forEach(v => unmount(v));
        }
        // 最后将新的文本节点内容设置给容器元素
        console.log('setElementText', nNode);
        setElementText(container, nNode.key ? nNode.children + ` _ key ${nNode.key}` : nNode.children);
      } else if (Array.isArray(nNode.children)) {
        patchKeyedChildren(oNode, nNode, container);
      } else {
        // 新子节点不存在，旧子节点是一组子节点，只需逐个卸载即可
        if (Array.isArray(oNode.children)) {
          oNode.children.forEach(v => unmount(v));
        } else if (typeof oNode.children === 'string') {
          // 旧子节点是文本子节点，清空内容即可
          setElementText(container, '');
        }
        // 没有子节点 没有操作
      }
      console.log(`----- patch oldTag: ${oNode.type}, newTag: ${nNode.type} -------------------`);
    }

    function patchKeyedChildren(oNode, nNode, container) {
      const oldChildren = oNode.children;
      const newChildren = nNode.children;
      // 四个索引值
      let oldStartIdx = 0;
      let oldEndIdx = oldChildren.length - 1;
      let newStartIdx = 0;
      let newEndIdx = newChildren.length - 1;
      // 四个索引指向的 vnode 节点
      let oldStartVNode = oldChildren[oldStartIdx];
      let oldEndVNode = oldChildren[oldEndIdx];
      let newStartVNode = newChildren[newStartIdx];
      let newEndVNode = newChildren[newEndIdx];

      if (oldStartVNode.key === newStartVNode.key) {

      } else if (oldEndVNode.key === newEndVNode.key) {

      } else if (oldStartVNode.key === newEndVNode.key) {

      } else if (oldEndVNode.key === newStartVNode.key) {
        patch(oldEndVNode, newStartVNode, container);

        insert(oldEndVNode.el, container, oldStartVNode.el);

        oldEndVNode = oldChildren[--oldEndIdx];

        newStartVNode = newChildren[++newStartIdx];
      }
    }


    const renderer = createRenderer(elementApi);
    const vnode = {
      type: 'div',
      children: [
        { type: 'p', children: '1', key: 1 },
        { type: 'p', children: '2', key: 2 },
        { type: 'p', children: 'hello', key: 3 },
      ]
    };
    console.log('初始渲染的 vnode', vnode);
    renderer.render(vnode, document.querySelector('#app'));

    setTimeout(() => {
      const vnode = {
        type: 'div',
        children: [
          { type: 'p', children: 'hello', key: 3 },
          { type: 'p', children: '1', key: 1 },
        ]
      };

      console.log('二次渲染的 vnode', vnode);


      console.log('``````````````````````` update `````````````````````');
      renderer.render(vnode, document.querySelector('#app'));
    }, 1000)
  </script>
</body>

</html>