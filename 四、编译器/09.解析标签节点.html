<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>解析标签节点</title>
</head>

<body>
  <div id="app"></div>
  <script src="../un-vue/utils.js"></script>
  <script src="../un-vue/reactivity.js"></script>
  <script src="../un-vue/render.js"></script>
  <script src="../un-vue/components.js"></script>
  <script src="../un-vue/compiler.js"></script>
  <script>
    // 定义文本模式，作为一个状态表
    const TextModes = {
      DATA: 'DATA',
      RCDATA: 'RCDATA',
      RAWTEXT: 'RAWTEXT',
      CDATA: 'CDATA'
    }

    function parseText(context) {
      // endIndex 为文本内容的结尾索引，默认将整个模板剩余内容都作为文本内容
      let endIndex = context.source.length;
      // 寻找字符 < 的位置索引
      const ltIndex = context.source.indexOf('<');
      // 寻找定界符 {{ 的位置索引
      const delimiterIndex = context.source.indexOf('{{');

      // 取 ltIndex 和当前 endIndex 中较小的一个作为新的结尾索引
      if (ltIndex > -1 && ltIndex < endIndex) {
        endIndex = ltIndex;
      }

      // 取 delimiterIndex 和当前 endIndex 中较小的一个作为新的结尾索引
      if (delimiterIndex > -1 && delimiterIndex < endIndex) {
        endIndex = delimiterIndex
      }

      // 此时 endIndex 是最终的文本内容的结尾索引，调用 slice 函数截取文本内容
      const content = context.source.slice(0, endIndex);
      // 消耗文本内容
      context.advanceBy(content.length);

      // 返回文本节点
      return {
        type: 'Text',
        content
      }
    }

    function parseAttributes(context) {
      const props = [];
      const { advanceBy, advanceSpaces } = context;
      while (!context.source.startsWith('>') && !context.source.startsWith('>')) {
        // 该正则用于匹配属性名称
        const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
        const name = match[0];  // 得到属性名称
        advanceBy(name.length);  // 消费属性名称
        advanceSpaces();  // 消费属性名称与等于号之间的空白字符
        advanceBy(1); // 消费等于号
        advanceSpaces();  // 消费等于号与属性值之间的空白字符
        let value = ''; // 属性值
        const quote = context.source[0];  // 获取当前模板内容的第一个字符
        // 判断属性值是否被引号引用
        const isQuoted = quote === '"' || quote === "'";
        if (isQuoted) {
          advanceBy(1); // 属性值被引号引用，消费引用
          // 获取下一个引号的索引
          const endQuoteIndex = context.source.indexOf(quote);
          if (endQuoteIndex > -1) {
            // 获取下一个引号之前的内容作为属性值
            value = context.source.slice(0, endQuoteIndex);
            advanceBy(value.length);  // 消费属性值
            advanceBy(1); // 消费引号
          } else {
            console.error('缺少引号')
          }
        } else {
          // 到此处 说明属性值并没有被引号引用
          // 下一个空白字符之前的内容全部作为属性值
          const match = /^[^\t\r\n\f >]+/.exec(context.source);
          value = match[0]; // 获取属性值
          advanceBy(value.length);  // 消费属性值
        }
        advanceSpaces();  // 消费属性值后面的空白字符
        // 使用属性名称 + 属性值创建一个属性节点 添加到 props 数组中
        props.push({
          type: 'Attribute',
          name,
          value
        })
      }
      return props
    }

    // 处理开始标签和结束标签
    function parseTag(context, type = 'start') {
      const { advanceBy, advanceSpaces } = context;
      // 处理开始标签和结束标签的正则表达式不同
      const match = type === 'start' ?
        /^<([a-z][^\t\r\n\f />]*)/i.exec(context.source)
        : /^<\/([a-z][^\t\r\n\f />]*)/i.exec(context.source);
      // 匹配成功后，正则表达式的第一个捕获组的值就是标签名称
      const tag = match[1];
      // 消费正则表达式匹配的全部内容，例如 ‘<div’ 这段内容
      advanceBy(match[0].length);
      // 消费标签中无用的空白字符
      advanceSpaces();

      // 属性与指令的解析，得到 props 数组
      // props 数组是由指令节点与属性节点共同组成的数组
      const props = parseAttributes(context);

      // 在消费匹配内容后，如果字符以 '/>' 开头，则说明这是一个自闭合标签
      const isSelfClosing = context.source.startsWith('/>');
      // 如果是自闭合标签，则消费 '/>'，否则消费 ‘>’
      advanceBy(isSelfClosing ? 2 : 1);
      // 返回标签节点
      return {
        type: 'Element',
        tag,  // 标签名称
        props,  // 标签的属性
        children: [], // 子节点
        isSelfClosing // 是否自闭合
      }
    }

    function parseElement(context, ancestors) {
      // 调用 parseTag 函数解析开始标签
      const element = parseTag(context);
      if (element.isSelfClosing) return element
      // 切换到正确的文本模式
      if (element.tag === 'texttarea' || element.tag === 'title') {
        // 如果是 texttarea title 则切换到 RCDATA 模式
        context.mode = TextModes.RCDATA;
      } else if (/style|xmp|iframe|noembed|noframes|noscript/.test(element.tag)) {
        context.mode = TextModes.RAWTEXT;
      } else {
        context.mode = TextModes.DATA;
      }

      ancestors.push(element);
      element.children = parseChildren(context, ancestors);
      ancestors.pop();

      if (context.source.startsWith(`</${element.tag}`)) {
        // 再次调用 parseTag 函数解析结束标签，传递了第二个参数 ‘end’
        parseTag(context, 'end');
      } else {
        console.error(`${element.tag} 标签缺少闭合标签`)
      }
      return element
    }

    function isEnd(context, ancestors) {
      // 当模板内容解析完毕后，停止
      if (!context.source) return true
      for (var i = ancestors.length - 1; i >= 0; --i) {
        if (context.source.startsWith(`</#{ancestors[i].tag}`)) {
          return true
        }
      }
      // 获取父级标签节点
      const parent = ancestors[ancestors.length - 1];
      // 如果遇到结束标签，并且该标签与父级标签节点同名，则停止
      if (parent && context.source.startsWith(`</${parent.tag}`)) {
        return true
      }
    }

    function parseChildren(context, ancestors) {
      // nodes 数组储存子节点，它将作为最终的返回值
      let nodes = [];
      // 从上下文对象中取得当前状态
      const { mode, source } = context;
      // 对字符串进行解析
      while (!isEnd(context, ancestors)) {
        let node;
        // 只有 DATA 模式和 RCDATA 模式才支持插值节点的解析
        if (mode === TextModes.DATA || mode === TextModes.RCDATA) {
          // 只有 DATA 模式才支持标签节点的解析
          if (mode === TextModes.DATA && source[0] === '<') {
            if (source[1] === '') {
              if (source.startsWith("<!--") ){
                // 注释
                node = parseComment(context);
              } else if (source.startsWith('<![CDATA[')) {
                // CDATA
                node = parseCDATA(context, ancestors);
              }
            } else if (source[1] === '/') {
              // 结束标签，这里需要抛出错误
              console.error('无效的结束标签');
              continue
            } else if (/[a-z]/i.test(source[1])) {
              // 标签
              node = parseElement(context, ancestors);
            }
          } else if (source.startsWith('{{')) {
            // 解析插值
            node = parseInterpolation(context);
          }
        }
        // node 不存在，说明处于其他模式，即非 DATA 模式且非 RCDATA 模式
        // 一切内容都作文本处理
        if (!node) {
          // 解析文本节点
          node = parseText(context)
        }
        // 将节点添加到 nodes 数组中
        nodes.push(node);
      }
      return nodes
    }

    // 解析器函数，接收模板作为参数
    function parse(str) {
      // 定义上下文对象
      const context = {
        source: str,  // 模板内容，用于在解析过程中进行消费
        mode: TextModes.DATA,  // 解析器当前处于文本模式，初始模式为 DATA
        // 用作消费指定数量的字符，它接收一个数字作为参数
        advanceBy(num) {
          // 根据给定字符数 num, 截取位置 num 后的模板内容，并替换当前模板内容
          context.source = context.source.slice(num);
        },
        // 无论是开始标签还是结束标签，都可能存在无用的空白字符，例如 <div >
        advanceSpaces() {
          // 匹配空白字符
          const match = /^[\t\r\n\f ]+/.exec(context.source);
          if (match) {
            // 调用 advanceBy 函数消费空白字符
            context.advanceBy(match[0].length);
          }
        }
      };
      // 获取解析后得到的子节点
      // 参数为 上下文对象和父代节点构成的节点栈，初始时栈为空
      const nodes = parseChildren(context, []);
      // 解析器返回 Root 根节点
      return {
        type: 'Root',
        children: nodes
      }
    }

    function compile(template) {
      // 模板 ast
      const ast = parse(template);
      console.log(JSON.stringify(ast, null, 2))
    }
    const str = `<div id="foo" v-show="display">text</div>`;
    // const str = `<div>+--<p>vue</p>+--<p>template</p>+</div>`;
    compile(str)

  </script>